#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('nodejs-regular-webapp2:server');
var http = require('http');
var httpProxy = require('http-proxy');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/* Proxy websockets */

var proxy = httpProxy.createProxyServer({
  target: {
    host: process.env.SHINY_HOST,
    port: process.env.SHINY_PORT
  },
  ws: true,
  proxyTimeout: (24 * 60 * 60 * 1000) // 1 day
});

proxy.on('error', function(err) {
    console.log(err);
});

/*
FIXME:

Websocket requests also require that the RStudio username header be present and
correct.

However, as Passport authentication does not handle websockets we can't use
req.user or req.session info for the username, as with HTTP requests. So instead
we take the username from the requested hostname instead.

This is imperfect, and should be replaced with an actual check for an active
authenticated session. However, as RStudio only uses websockets for Shiny app
previews, on paths including the current session ID and a randomly assigned
port, websocket URLs are impossible to guess or enumerate without an active
authenticated HTTP session, the security risk is minimal at worst.
*/
proxy.on('proxyReqWs', function(proxyReqWs, req, res, options) {
    var matches = /^(.*)-rstudio\..*/.exec(req.headers.host);
    if(matches[1]){
      proxyReqWs.setHeader('X-RStudio-Username', matches[1]);
    }
});

server.on('upgrade', function (req, socket, head) {
  var target = 'ws://' + process.env.SHINY_HOST + ':' + process.env.SHINY_PORT;
  proxy.ws(req, socket, head, {target: target});
});


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
